// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: candidate.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createCandidate = `-- name: CreateCandidate :one
INSERT INTO candidates (
    username,
    full_name,
    phone_number,
    education,
    location,
    skill_set,
    certificates,
    industry_of_interest,
    job_preference,
    time_availability,
    account_verified,
    resume_file,
    profile_photo,
    description
) VALUES (
             $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14
         ) RETURNING id, username, full_name, phone_number, education, location, skill_set, certificates, industry_of_interest, job_preference, time_availability, account_verified, resume_file, profile_photo, description, created_at
`

type CreateCandidateParams struct {
	Username           string        `json:"username"`
	FullName           string        `json:"full_name"`
	PhoneNumber        string        `json:"phone_number"`
	Education          Education     `json:"education"`
	Location           string        `json:"location"`
	SkillSet           []string      `json:"skill_set"`
	Certificates       []string      `json:"certificates"`
	IndustryOfInterest string        `json:"industry_of_interest"`
	JobPreference      JobPreference `json:"job_preference"`
	TimeAvailability   []byte        `json:"time_availability"`
	AccountVerified    bool          `json:"account_verified"`
	ResumeFile         string        `json:"resume_file"`
	ProfilePhoto       string        `json:"profile_photo"`
	Description        string        `json:"description"`
}

func (q *Queries) CreateCandidate(ctx context.Context, arg CreateCandidateParams) (Candidate, error) {
	row := q.db.QueryRow(ctx, createCandidate,
		arg.Username,
		arg.FullName,
		arg.PhoneNumber,
		arg.Education,
		arg.Location,
		arg.SkillSet,
		arg.Certificates,
		arg.IndustryOfInterest,
		arg.JobPreference,
		arg.TimeAvailability,
		arg.AccountVerified,
		arg.ResumeFile,
		arg.ProfilePhoto,
		arg.Description,
	)
	var i Candidate
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.FullName,
		&i.PhoneNumber,
		&i.Education,
		&i.Location,
		&i.SkillSet,
		&i.Certificates,
		&i.IndustryOfInterest,
		&i.JobPreference,
		&i.TimeAvailability,
		&i.AccountVerified,
		&i.ResumeFile,
		&i.ProfilePhoto,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const deleteCandidate = `-- name: DeleteCandidate :exec
DELETE FROM candidates
WHERE id = $1
`

func (q *Queries) DeleteCandidate(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteCandidate, id)
	return err
}

const getCandidate = `-- name: GetCandidate :one
SELECT id, username, full_name, phone_number, education, location, skill_set, certificates, industry_of_interest, job_preference, time_availability, account_verified, resume_file, profile_photo, description, created_at FROM candidates
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetCandidate(ctx context.Context, id int64) (Candidate, error) {
	row := q.db.QueryRow(ctx, getCandidate, id)
	var i Candidate
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.FullName,
		&i.PhoneNumber,
		&i.Education,
		&i.Location,
		&i.SkillSet,
		&i.Certificates,
		&i.IndustryOfInterest,
		&i.JobPreference,
		&i.TimeAvailability,
		&i.AccountVerified,
		&i.ResumeFile,
		&i.ProfilePhoto,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const getCandidateIdByUsername = `-- name: GetCandidateIdByUsername :one
SELECT id FROM candidates
WHERE username = $1 LIMIT 1
`

func (q *Queries) GetCandidateIdByUsername(ctx context.Context, username string) (int64, error) {
	row := q.db.QueryRow(ctx, getCandidateIdByUsername, username)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const listCandidates = `-- name: ListCandidates :many
SELECT id, username, full_name, phone_number, education, location, skill_set, certificates, industry_of_interest, job_preference, time_availability, account_verified, resume_file, profile_photo, description, created_at FROM candidates
WHERE username = $1
ORDER BY id
LIMIT $2
    OFFSET $3
`

type ListCandidatesParams struct {
	Username string `json:"username"`
	Limit    int32  `json:"limit"`
	Offset   int32  `json:"offset"`
}

func (q *Queries) ListCandidates(ctx context.Context, arg ListCandidatesParams) ([]Candidate, error) {
	rows, err := q.db.Query(ctx, listCandidates, arg.Username, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Candidate{}
	for rows.Next() {
		var i Candidate
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.FullName,
			&i.PhoneNumber,
			&i.Education,
			&i.Location,
			&i.SkillSet,
			&i.Certificates,
			&i.IndustryOfInterest,
			&i.JobPreference,
			&i.TimeAvailability,
			&i.AccountVerified,
			&i.ResumeFile,
			&i.ProfilePhoto,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCandidate = `-- name: UpdateCandidate :one
UPDATE candidates
SET full_name = COALESCE($2, full_name),
    phone_number = COALESCE($3, phone_number),
    education = COALESCE($4, education),
    location = COALESCE($5, location),
    skill_set = COALESCE($6, skill_set),
    certificates = COALESCE($7, certificates),
    industry_of_interest = COALESCE($8, industry_of_interest),
    job_preference = COALESCE($9, job_preference),
    time_availability = COALESCE($10, time_availability),
    account_verified = COALESCE($11, account_verified),
    resume_file = COALESCE($12, resume_file),
    profile_photo = COALESCE($13, profile_photo),
    description = COALESCE($14, description)
WHERE
    id = $1
RETURNING id, username, full_name, phone_number, education, location, skill_set, certificates, industry_of_interest, job_preference, time_availability, account_verified, resume_file, profile_photo, description, created_at
`

type UpdateCandidateParams struct {
	ID                 int64             `json:"id"`
	FullName           pgtype.Text       `json:"full_name"`
	PhoneNumber        pgtype.Text       `json:"phone_number"`
	Education          NullEducation     `json:"education"`
	Location           pgtype.Text       `json:"location"`
	SkillSet           []string          `json:"skill_set"`
	Certificates       []string          `json:"certificates"`
	IndustryOfInterest pgtype.Text       `json:"industry_of_interest"`
	JobPreference      NullJobPreference `json:"job_preference"`
	TimeAvailability   []byte            `json:"time_availability"`
	AccountVerified    pgtype.Bool       `json:"account_verified"`
	ResumeFile         pgtype.Text       `json:"resume_file"`
	ProfilePhoto       pgtype.Text       `json:"profile_photo"`
	Description        pgtype.Text       `json:"description"`
}

func (q *Queries) UpdateCandidate(ctx context.Context, arg UpdateCandidateParams) (Candidate, error) {
	row := q.db.QueryRow(ctx, updateCandidate,
		arg.ID,
		arg.FullName,
		arg.PhoneNumber,
		arg.Education,
		arg.Location,
		arg.SkillSet,
		arg.Certificates,
		arg.IndustryOfInterest,
		arg.JobPreference,
		arg.TimeAvailability,
		arg.AccountVerified,
		arg.ResumeFile,
		arg.ProfilePhoto,
		arg.Description,
	)
	var i Candidate
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.FullName,
		&i.PhoneNumber,
		&i.Education,
		&i.Location,
		&i.SkillSet,
		&i.Certificates,
		&i.IndustryOfInterest,
		&i.JobPreference,
		&i.TimeAvailability,
		&i.AccountVerified,
		&i.ResumeFile,
		&i.ProfilePhoto,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}
